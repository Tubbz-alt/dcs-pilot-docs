---
title: Message structure
weight: 4
last_reviewed_on: 2020-02-24
review_in: 6 weeks
---

# Message structure

Messages your client exchanges with the Document Checking Service (DCS) must be signed and encrypted using the following Internet Engineering Task Force
(IETF) standards:

 - [JavaScript Object Notation (JSON)][JSON]
 - [JavaScript Object Signing and Encryption (JOSE)][JOSE]
 - [JSON Web Signature (JWS)][JWS]
 - [JSON Web Encryption (JWE)][JWE]

The JSON object in request and response bodies is protected by a signature and encryption wrapper.

To build the signature (JWS) and encryption (JWE) wrapper for your JSON object, you must:

1. Sign your JSON object with your signing key using JWS.
2. Encrypt your signed JSON object with the DCS's public encryption certificate using JWE.
3. Sign the encrypted content with your signing key using JWS.

<%= image_tag "dcs-message-structure-sequence.svg", { :alt => '' } %>



> JWE header comes from the cert but the signing is

> Getting enc certificate from where?

## 1. Sign your JSON object

You start off with a JSON object containing the details of the passport you want to check.

```json
{
  "correlationId": "550e8400-e29b-41d4-a716-446655440000",
  "requestId": "550e8400-e29b-41d4-a716-446655440003",
  "timestamp": "1997-07-16T19:20:30.45+01:00",
  "clientId": "clientName",
  "passportNumber": "123456789",
  "surname": "Smith",
  "forenames": [
    "Bob",
    "Dave"
  ],
  "dateOfBirth": "1950-02-13",
  "expiryDate": "2020-01-01"
}
```

Signing your JSON object using the JWS protocol, produces a JWS object.

Depending on the JOSE librry you use, you might have to manually construct the JWS header:

```json
    "x5t#S256":"gGzb5v_MNfiC0QHur40xZpZyKCVzy7KeZyzFCVi_BrI",
    "x5t":"K9gFum5l_xYyHwCniYljJ4Lh_vY",
    "alg":"RS256"
```

`x5t#S256` - Tom looking into a CyberChef recipe. Or else some pseudocode
`x5t` - same as above

`alg` - set it to `RS256`. The `alg` header in the JWS object must be set to RS256 to create a protected header.

`TODO` To do the actual JWS, it's a good idea to use a pre-existing library if available for your language. link to the list of libraries.

> TODO what keys and certs to they need to generate and/or get. Talk to Paul, Alex M, Alex W

> TODO are the 3 JSON objects enough to produce the JWS object after applying some sort of library function?

signature is generated by the library
you need to provide

- header
- payload
- signing key

and your JOSE library will produce the JWS object. Then move on to the encryption step.

> TODO publish examples of JOSE libraries at the end of this page - check with Paul.

> TODO put generic info about singing and encryption in a separate page about securing messages. Have this page be just about building the messages. Links to open-sourced libraries/reference implementation should be both at the top and the bottom of the page

> TODO are "BASE_64_ENCODED_BLOB_JWE_PAYLOAD" and "BASE_64_ENCODED_BLOB" from the original sample the same thing?

> TODO re-draw the image with arrows as the layers are built. -done

## Andrea

> TODO timestamp in the passport details JSON - make it 2019

The parts of the resulting JWS are:

- JWS header
- base64url-encoded JSON object containing the passport details
- JWS signature

Here's an outline of your JWS object:

```json
{
    "JWS_HEADER": {
        "x5t#S256":"gGzb5v_MNfiC0QHur40xZpZyKCVzy7KeZyzFCVi_BrI",
        "x5t":"K9gFum5l_xYyHwCniYljJ4Lh_vY",
        "alg":"RS256"
    },
    "BASE_64_ENCODED_PAYLOAD": {
      "correlationId": "550e8400-e29b-41d4-a716-446655440000",
      "requestId": "550e8400-e29b-41d4-a716-446655440003",
      "timestamp": "1997-07-16T19:20:30.45+01:00",
      "clientId": "clientName",
      "passportNumber": "123456789",
      "surname": "Smith",
      "forenames": [
        "Bob",
        "Dave"
      ],
      "dateOfBirth": "1950-02-13",
      "expiryDate": "2020-01-01"
    },
    "JWS_SIGNATURE": "VGhpcyBpcyBhIEJhc2U2NCBVUkwu..."
}
```

#### `JWS_HEADER`

Contains information that will produce the signature in `JWS_SIGNATURE`

`x5t#S256` is a base64url-encoded SHA256 thumprint digest of signing certificate

`x5t`  is a base64url-encoded RSA1 thumprint digest of signing certificate
> TODO whose signing certificate

The `alg` header in the JWS object must be set to RS256 to create a protected header.

#### `BASE_64_ENCODED_PAYLOAD`
Is your unencrypted and unsigned base64url-encoded payload.

#### `JWS_SIGNATURE`
is a base64url-encoded using RS256, as specified in the `alg` element of the `JWS_HEADER`.


### 2. Encrypt your JWS object

Encrypting your JWS object using the JWE protocol, produces a JWE object.

```json
{
  "enc":"A128CBC-HS256",
  "alg":"RSA-OAEP",
  "typ":"JWE",
  "x5t":"xiWgxFMOIw1M4m9LYCnKZk5eHJs",
  "x5t#S256":"PJLEl_B6MFKaMEG6HK7BBdaueJc7e-SiimQfvEpTYj4"
}
```
`x5t`-stuff is for the encryption certificate. Recipes from JWS will also work - thanks Tom :D
other stuff is just you-must-set-this-to-that.

*Create payload*
you need:
- header created above
- [encryption key](link to where this is generated)
- signed payload from earlier - the entire JWS object that we're supplying as a parameter

Output from the library you're using to do the JWE - JWE object base64url-encoded.


### 3. Sign your JWE object

Signing your JWE object using the JWS protocol, produces a JWS object.

This is the mental model of the base 64 encoded "blob" (DCS payload) structure. You will not see this bec


1. encode using all 3 layers
2. breaking up the base 64 blob into 3 parts - JWS header, contnet (base 64 encoded blob), JWS signature)
3. base 64 decode JWS header and you get what's under `"JWS_HEADER"` in the code example.
4. base 64 decode the second segment `BASE_64_ENCODED_BLOB` and that removes the signature from layer 3. then you're left with the JWE layer (2). break it down again and you get 5 layers: header, key, vector, data, tag. then you need to decrypt the data segment and you're left with a base 64 URL (change everywhere!).
5. the new base64 URL - basee 64 decode and get 3 segments: header, blob, signature.

use payload instead of blob



Reply

DCS signing certificate to check the origin and integrity of the message
Your encryption key to decrypt the payload
DCS signing key again to check origin and integrity of the resposne from DCS

> question: does the response for status request also have the bento box?

```json
{
    "JWS_HEADER" [this is 3 in the diagram]: {
        "x5t#S256":"gGzb5v_MNfiC0QHur40xZpZyKCVzy7KeZyzFCVi_BrI", # Base4url encoded SHA256 thumprint digest of signing certificate
        "x5t":"K9gFum5l_xYyHwCniYljJ4Lh_vY", # base64url encoded RSA1 thumprint digest of signing certificate
        "alg":"RS256" # Algorithm for the JWS_SIGNITURE
    },
    "BASE_64_ENCODED_BLOB": {
        "BASE_64_ENCODED_BLOB_JWE_PAYLOAD": {
            "JWE_HEADER": {
                "x5t#S256":"7E_EW481StVz0CUsX-P1-LqaKC5-OLdOUHKqpSZHLZg", # Base4url encoded SHA256 thumprint digest of encryption certificate
                "x5t":"yZ6e43JwzEznBqaBHl3xcPWtZjo", # base64url encoded RSA1 thumprint digest of encryption certificate
                "enc":"A128CBC-HS256",
                "alg":"RSA-OAEP"
            },
            "ENCYPTED_ENCYPTION_KEY": "Encrypted Binary Blob",
            "ENCRYPTION_VECTOR": "Binary", # used for the A123CBC encryption
            "ENCRYPTED_DATA": {
                "BASE64URL_ENCODED_JWS_HEADER": {
                    "x5t#S256":"gGzb5v_MNfiC0QHur40xZpZyKCVzy7KeZyzFCVi_BrI", # Base4url encoded SHA256 thumprint digest of signing certificate
                    "x5t":"K9gFum5l_xYyHwCniYljJ4Lh_vY", # base64url encoded RSA1 thumprint digest of signing certificate
                    "alg":"RS256"
                },
                "BASE64URL_ENCODED_BLOB": { // Our payload, unencrypted and unsigned
                    "expiryDate": "2120-01-01",
                    "timestamp": "2019-12-10T15:25:52.478Z",
                    "requestId": "AF527533-80FE-4B49-BF3C-6C7512AEA835",
                    "passportNumber": "123456",
                    "forenames": ["DEFAULT", "FORENAMES"],
                    "correlationId": "DE2EBF78-4B4C-4FBF-B49D-F5CDF530A666",
                    "clientId": "DEFAULT CLIENT",
                    "surname": "DEFAULT SURNAME",
                    "issuingCountryCode": "GBR",
                    "dateOfBirth": "1900-01-01"
                },
                "JWS_SIGNATURE_BASE64URL": This is a Base4url encoded using RS256 (RSA Signature with SHA-256).
            }
            "AUTHENTICATION_TAG": this is a artifact of the encryption process.
        }
    },
    "JWS_SIGNATURE": This is a Base4url encoded using RS256 (RSA Signature with SHA-256).
}
```





## Signing messages

Signing provides the receiver with assurance of who authored the message. The signature also guarantees that the message hasn’t been tampered with since the author signed it.

Your client signs requests with your private signing key. When receiving the request, the DCS uses your signing certificate to verify that the request came from your client.

Responses from the DCS are signed with the DCS's private signing key. Your client uses the DCS's signing certificate to verify that the response came from the DCS.

### Signing keys and certificates

You must generate a private signing key and raise a certificate signing request to our Certificate Authority. Details about how to raise a certificate signing request with our Certificate Authority will follow after the expression of interest stage of the DCS pilot.

You will receive the DCS’s signing certificate from the DCS team.

### Signing algorithms

Signatures in the JOSE message must use [RSASSA-PKCS1-V1_5] with the `SHA-256` hashing algorithm for RSA-based keys, as detailed in the [JSON Web Algorithms] specification.

The [`alg` header in the JWS object][jws-alg-header] must be set to `RS256`.

You must set the [`x5t`][jws-x5t-header] and [`x5t#256`][jws-x5t256-header] headers. The DCS uses these headers to confirm that the certificate used to sign the JWS object was signed by our Certificate Authority.

## Encrypting messages

Encryption provides the sender with assurance that only the intended receiver can see the message.

Your client encrypts requests using the DCS's encryption certificate. When receiving the request, the DCS uses its private encryption key to decrypt your request.

Responses from the DCS are encrypted with your encryption certificate. Your client then uses your private encryption key to decrypt the response from DCS.

### Encryption keys and certificates

You must generate a private encryption key and raise a certificate signing request with our Certificate Authority. Details about how to raise a certificate signing request with our Certificate Authority will follow after the expression of interest stage of the DCS pilot.

You will receive the DCS’s encryption certificate from the DCS team.

### Encryption algorithms

The encrypted component of the JOSE message must use:

 * [RSAES-OAEP] as the algorithm, detailed in the [JSON Web Algorithms specification][JWA]
 * [A128CBC-HS256] as the encryption method, detailed in the [JSON Web Algorithms specification][JWA].

The [`alg` header in the JWE object][jwe-alg-header] must be set to `RSA-OAEP` or `RSA-OAEP-256`.

The [`enc` header in the JWE object][jwe-enc-header] must be set to `A128CBC-HS256`.

<%= partial "partials/links" %>
